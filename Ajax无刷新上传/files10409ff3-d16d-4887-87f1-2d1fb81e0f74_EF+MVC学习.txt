  在C#中var是强类型语言,它表示类型推断,因为在声明的时候就必须初始化,然后编译的时候就知道是什么类型了。
  dynamic是弱类型的语言，只有在运行时才知道是什么类型的语言。
  初始化:构造方法||初始化器 对于必须的及数据库中不能为空的使用构造方法进行初始化，其余的使用初始化器进行初始化。
  先调用构造方法再调用初始化器。
-------------------------【反射】--------------   
  反射优点:在不引用文件的时候，直接把dll文件Copy到文件夹里面，就可以用反射进行操作。 
  程序集文件包括:.dll 和 .exe文件
  反射中的对应关系:
  物理状态对应内存状态
  Lib.dll->Assembly
  类->type
  方法->MethodInfo
  属性->PropertyInfo
  字段->Feild
  -----------------反射举例:
   //1.将Pig类所在的程序集lib.dll加载到内存
            Assembly ass = Assembly.LoadFile(@"D:/documents/visual studio 2010/Projects/反射/反射/bin/Debug/Lib.dll");//根据绝对路径加载，有局限性			
            //2.必须使用反射动态创建pig对象
            object pigInstance = ass.CreateInstance("Lib.Pig");//相当于new Pig();
            //3.先给Pig中的Name赋值
            Type PigType = ass.GetType("Lib.Pig");
            PropertyInfo nameInfo = PigType.GetProperty("Name");  
			nameInfo.SetValue(pigInstance, "八戒，八戒",null);//->4.0的写法
            nameInfo.SetValue(pigInstance, "八戒，八戒");//设置Pig中Name属性的值->4.5的写法
			object obj = nameInfo.GetValue(pigInstance,null);//->4.0的写法
            object obj = nameInfo.GetValue(pigInstance); //4.获取Pig中Name属性的值,->4.5的写法
	【获取Assembly的几种写法】:
     Assembly ass = Assembly.Load("Lib");//根据相对路径加载,无局限性,括号里面不用写后缀名
     Assembly[] ass=AppDomain.CurrentDomain.GetAssemblies();//获取当前程序域中,所有的Assembly	
    【获取Type类型的几种写法】:
	1.Type[] allType=ass.GetTypes();//获取所有的程序集中所有类的Type（包括公有，私有，保护）
	2.Type pigType=ass.GetType("Lib.Pig",false,true);//第二个参数表示是否抛出异常,
	第三个参数表示是否忽略大小写
	3.Type f1=typeof(Form1);
	4. Type[] publicTypes = ass.GetExportedTypes();//获取程序集中所有公共的类
    应用程序域作用:用于隔离两个应用程序域之间的内存
	5.对于构造函数的赋值方式
	 Type perType = ass.GetType("Per.Mike");
            ConstructorInfo cinInfo = perType.GetConstructor(new Type[] {typeof(string),typeof(int) });//指定赋值的构造函数
            object obj= cinInfo.Invoke(new Object[] {"麦克",22 });//开始初始化
	【获取私有字段的写法】
	   Assembly ass = Assembly.Load("Per");//加载程序集,及dll文件
            Type mikeType = ass.GetType("Per.Mike");//获取Mike类
            Object mikeObj = ass.CreateInstance("Per.Mike");//相当于new Mike();
            FeildInfo mikeInfo = mikeType.GetFeild("_age",BindingFlags.NonPublic|BindingFlags.Static);//获取私有字段//非公共的//静态的
            mikeInfo.SetValue(mikeObj, 22);//设置值
            object obj = mikeInfo.GetValue(mikeObj) ;//获取值
            MessageBox.Show(obj.ToString());
	
    GAC(全局应用程序集缓存)的作用:用于存放各个程序都需要使用的共同程序集
   ------------在配置文件中存储部分数据--
    <appSettings><add key="" value=""></appSettings>
	------------【简单工厂设计模式】-------
	用途:用于方便切换数据库时便利,将数据放在配置文件里面，然后利用反射获取对象返回给接口。
	[具体看RYJ.Shop项目]
	-----------【EF】-----------
	创建:在数据里面选择Ado.Net数据模型
	优点：1.极大的提高开发效率:EF是微软自己的产品,跟VS集成度比较好,开发代码都是强类型的,写代码效率非常高,自动化程度非常高，命令式的编程
	2.EF提供的模型设计器非常强大,不仅带来了设计数据库的革命,附带的自动化功能也极大提高开发和设计的效率
	3.EF跨数据库是ORM主要功能点之一,带来的是仅仅通过数据库配置就可以实现跨数据库的能力
	4.缺点:性能差(生成sql脚本的阶段),在复杂查询的时候生成sql脚本的效率并不高
	
	DelDemo fun=delegate(int a,int b){return a>b;};//匿名方法
	DelDemo fun=(int a,int b)=>{return a>b;};//Lambda语句
	DelDemo fun=(int a,int b)=>a>b;//Lambda表达式
	  System.Web.Caching.Cache cache = HttpRuntime.Cache;//设置缓存
	ORM是种思想，是表实体和表之间的相互转换
	EF表必须有主键
    EF：是实际操作
	  [添加数据操作]
	  //第一步：创建访问数据库的统一入口,创建EF的上下文
            Inferno3Entities userInfo = new Inferno3Entities();
            //第二步：操作实体
            Users us = new Users();
            us.loginId = "shun7fire";
            us.loginPwd = "666";
            //第三步：告诉上下文咱们对实体做添加操作
            userInfo.Users.Add(us);//这可以改成userInfo.Entry(us).State = EntityState.Added;//增删改都可以这样实现	
            //第四步：告诉上下文去保存吧
            userInfo.SaveChanges();
	  linq定义:可以使用C#语言以查询数据库的方式操作内存数据
     EF中【linq查询】
            var data = from u in contextInfo.Product  --1.先指定谁从哪里查询 （上下文.查询对象)
                       where u.Id > 2     --2.然后指定 查询范围,或定义其他条件
                       select u;         --3.最后声明查询
		    可以不用var，直接定义类型IQueryable<TestFactory> 
			并且这句话会延迟加载,如果.ToList()就会立即执行	
			延迟加载:就是需要什么才执行什么			
	EF中【标准查询】运算符	
	contextInfo.ZhuCe.Find(id);
	contextInfo.ZhuCe.Where(u=>u.id==id);	
    contextInfo.ZhuCe.Where(u => u.id == id).FirstOrDefault();//返回满足默认条件的第一个数据,如果为空则返回默认值	
	【linq查询和标准查询】的区分:最终linq最终生成的就是标准查询运算符
    -----------【用EF实现 分页操作】-------
	查询语句后添加.Skip(每页条数*(要查询的页数-1))//跳过要查询的页数//.Take(要查询的条数)
	 以下是lanq表达式写法：
	分页举例： var data = (from u in contextInfo.AreaFull
                        orderby u.AreaId descending
                        select u).Skip(5 * (6 - 1)).Take(5);//查询第六页的五条数据，每页有五条    
	 以下是Lambda表达式写法:
	         var data = contextInfo.AreaFull.OrderBy(u => area.AreaId).Skip(5 * (6 - 1)).Take(5); 
	
	-----------查询的数据库语句，不是都查询出来然后再到VS筛选显示，而是从数据库直接查好了，然后才返回给VS  
    
	ascending//升序排列   //例如:orderby Id ascending
	descending//降序排列
	
	查询出来的实体(默认被EF所跟踪),直接修改属性,SaveChanges自动把实体更新数据库。
	EF中上下文实例管理：Winfrom中一个窗体共用一个上下文，Web中一次请求共用一个上下文
	ObjectContext是一种模型优先的开发模式，DbContext是代码优先的开发模式
	
	
	---------------------------------以上是EF相关介绍，下面开始MVC内容------
	MVC(model view controller)
	创建:选择Asp.Net MVC Web应用程序
	转换思想：一个方法相当于一个一般处理程序	
	控制器方法都称为action
	controller(控制器)的职责:1.处理用户交互  2.调用业务逻辑 3.指定一个视图展示数据
	【MVC中Controller和View中数据传递总结】
	传递:1.使用ViewData-->ViewData[“Message_ViewData”] = “ Hello ViewData!”;
	接收:1.@Html.Encode(ViewData["Message_ViewData"])
	传递:2.使用ViewBag-->ViewBag.Message_ViewBag =  “ Hello ViewBag !”;
    接收:2.@Html.Encode(ViewBag.Message_ViewBag)  
	传递:3.使用Model-->这个首先要创建强类型View  ViewData.Model=db.ZhuCe.ToList();
	接收:3.<% foreach (var item in Model)>{} 
	【请求特点】
	MVC里面所有请求都是控制器下面的一个方法
	访问MVC界面时,后面是端口号/控制器名(不包含Controler这部分)/方法名 例如:3100/Home/Index
	
	【代码后置】(code behind):从物理上说，是两个独立的文件。所以叫做代码后置。
	职责:处理用户交互,调用业务逻辑,把数据放到控件上去展示。
	
	string str=str??string.Empty;//如果为空则返回后面那个，不为空则返回自身
	
	
    【SKU】：用来描述库存商品唯一指定的量
   
    在IIS中部署后启动网页，要想在VS中调试采用：调试->附加进程 选择进程实现
	
	[HttpGet]代表只接收Get请求 [HttpPost]代表只接收Post请求
	RedirectToAction:跳转到指定界面
   【FormCollection】用来在controller中获取页面表单元素的数据。它是表单元素的集合，包括<input type="submit" />元素。
	public ActionResult Editor(FormCollection collection)//()里也可以定义为name属性,(string txtName)这样就会自动同步数据
	GPR->Get Post Redirect
    int?id//可空类型定义，这样id就可以为null啦
    【自定义扩展方法】:里面要定义静态类和静态方法,并且把命名空间设置为所扩展的类型所在的命名空间
	 MVC中扩展方法通常定义到Models里面,大致结构如下:
	 namespace System.Web.Mvc
     {
     public static HtmlString ShowPageNavigate(this HtmlHelper htmlHelper, int currentPage)
        {
		 return new HtmlHelper("");
		}
    }   
	 注意扩展方法就相当于a.方法 能点出来这个方法使用了，并不是讨论的继承相关的
	【使用JQ校验】-->引入JQ文件 and jquery.validate.js文件
	 写法:$("form").validate(rules{里面写条件},messages{里面写显示内容});注意都为JSON格式
	 
   //元数据(Metadata):就是程序集的说明书
    //程序集包括什么? IL,Metadata,resource,程序集清单
    问题：当用一个控制器生成两个不同名字的视图时，找不到文件怎么回事？
	答：仅仅需要改变控制器里面的action的名字和视图名字对应就OK了
    【MVC伙伴类校验】
	 1. [MetadataType(typeof(校验类))] 2.定义一个和表名相同的部分类(在Mocel里面定义，文件名可以不同) 3.定义一个校验类
	 校验通常用到的几种方法:
     1.必须填：[Required(ErrorMessage="*必填")]	2.最大长度:[StringLength(5,ErrorMessage="*不能超过5个字符")] 
	 3.范围:[Range(3,7,ErrorMessage="*必须是3-7之间的一个数字")] 
	 4.正则:[RegularExpression("正则",ErrorMessage="*必须是邮箱")]
    【MVC分页查询】  
	 View显示：
	<div id="dvShow">
        <%
            int pageIndex=ViewBag.pageIndex;
            int pageSize=ViewBag.pageSize;
            int pageCount=ViewBag.totalCount;
            
             %>
        <%:Html.ShowPageNavigate(pageIndex,pageSize,totalCount)%>
    </div>
     Controller传值:
	   //分页的超级链接给我们传这个数据
            int pageIndex = Request["pageIndex"] == null ? 1 : int.Parse(Request["pageIndex"]);
            int pageSize = Request["pageSize"] == null ? 8 : int.Parse(Request["pageSize"]);
            int totalCount = 0;
                //给前台传递分页数据           
            ViewData["pageIndex"] = pageIndex;          
            ViewBag.pageSize = pageSize;//另一种传递数据方式
            totalCount = db.ZhuCe.Count();
            ViewBag.totalCount = totalCount;
            //将当前页面数据发送给后台
            ViewData.Model = db.ZhuCe
                .OrderBy(u => u.id)
                .Skip((pageIndex - 1) * pageSize)
                .Take(pageSize).ToList();
	【MVC中往前台发送一个字符串】:return Content(DateTime.Now.ToString());
	【MVC中通过JQ异步请求获取后台数据】:
	 $(function () {
            $("#btnGetTime").click(function () {
                $.get("/Ajax/GetTime/", function (_data) {
                    alert(_data);
                });
            });
        });
    【MVC异步表单提交】
	 引入文件:jq文件和jquery.unobtrusive-ajax.js文件
     $("#EditUser form").submit();//提交整个表单
	 //要提交的表单(注:MVC异步书写格式)
	 <%using (Ajax.BeginForm("Edit", new AjaxOptions() { OnSuccess = "afterEdit" }))
              { %>
			 要提交的数据
			 <%}%>
	 ---后台代码
      var user = db.ZhuCe.Find(id);//根据ID查询对象	  
	  //为了编辑时避免重复调用（循环调用）,经过处理后返回
	  var sendData = new {user.id,user.password,user.userName};
	  or这样处理
	  .Select(u => new { u.age,u.gender,u.name,u.TeaId});
      return Json(sendData, JsonRequestBehavior.AllowGet);	//返回JSON数据
	【IEnumerable】它是一个真正的集合访问器，没有它，就不能使用foreach语句遍历集合或数组，因为只有IEnumerator对象才能访问集合中的项
	 特性标签[]一般都以Attribute来结尾
    【过滤器】:在Models里面定义一个MyActionFilterAttribute方法，并继承自ActionFilterAttribute，
	 然后重写继承方法
	在控制器上面加上 [MyActionFilterAttribute()]标记即可实现自动调用，加到总的控制器上面即可实现全局调用
	这个遵循就近原则，要想都实现，在自己定义的方法上面添加[AttributeUsage(AttributeTargets.All,AllowMultiple=true)]//允许多个Attribute起作用
    【路由】:
     Route:路由规则对象，定义URL规则格式
	 RouteCollection:路由规则对象，对上面的对象做了集合封装
	 RouteData:路由数据对象。URL地址根据路由规则进行解析后,得到的数据就是路由数据对象。
	 RouteTable:路由表。里面封装了一个静态的RouteCollection属性。
     ----查看路由规则匹配界面
	 1.添加RouteDebug.dll引用  
	 2. RouteDebug.RouteDebugger.RewriteRoutesForTesting(RouteTable.Routes);//注册完后添加这段代码
	 【Razor的使用】
	 例如:
	   @for (int i = 0; i < 10; i++)        
         {   <p>@i</p> }
        
     【单元测试】:用来测试某个方法是否正确
	 创建方式:
	 一.使用建立单元测试项目:[解决方案->添加->测试->单元测试项目]
	 二.也可以下载一个Unit Test Generator插件:【工具】-->【扩展和更新】-->搜索““Unit Test Generator””取得。下载完后右键要测试的方法->Generate Unit Test即可
	 单元测试举例:
	        int num1 = 20;
            int num2 = 20;
            Assert.AreEqual(Program.Add(num1, num2), 40);//如果运行成功，证明方法正确
			
	 【IList】//是所有泛型列表的基接口,会立即执行   当你只想使用接口的方法时,ILis<>这种方式比较好.他不获取实现这个接口的类的其他方法和字段，有效的节省空间．
			
	 【IQueryable】//作用和IList一样，但会延期执行
	   public IQueryable<T> Select()
        {
            return db.Set<T>().AsQueryable();//将数据转换为IQueryable类型
        }
	 ------- public class BaseDal<T> where T:class,new()//定义T必须是类，且必须含有默认构造函数	
	 -------要学会创建基类减少代码冗余
     【简单工厂】:
	  简单的说就是封装一个方法创建对象
	  
     【抽象工厂】:
	  抽象工厂和简单工厂的区别是:简单工厂创建对象时还是new一个方法,而抽象工厂则是【利用反射】加载Web中的
	  AppSetting获取对象
	 【T4模板】:
	  建立文本模板,后缀tt
	 【IOC】控制反转,是一个重要的面向对象编程的法则来削减计算机程序的耦合问题
	 【log4Net】用来记录日志文件，需要分三步:
	 1.引用log4net.dll程序集 2.配置web.config文件 3.写一个LogHelper类 最后就是把要记录日志的地方做标记
	 ----需要注意的是:LogHelper类命名空间上面需要加标记
	 【日志处理】:看日志处理log4net demo
	 【LigerUI】基于jQuery开发的一系列控件组
	 【Spring.Net】将要new的对象直接注入:
	 注意：如果是静态属性的话,如果想让它有注入的值，那么必须创建一个实例后，才会注入。
	 public static IUser User{get;set;}
	 可以在构造方法中这样实例:
	 IApplicationContext ctx=ContextRegistry.GetContext();
     var userInfoDal=ctx.GetObject("配置此类时配置文件里面定义的名字") as 类名;
	 例如:
	 public  class CacheHelper
     {
        public static ICacheWriter CacheWriter { get; set; }
        static CacheHelper()//静态的
        {
            IApplicationContext ctx = ContextRegistry.GetContext();
            var userInfoDal = ctx.GetObject("CacheHelper") as CacheHelper;
        }
	 
	 
	 
	 1.添加Common.Logging.dll、Spring.Core.dll、Spring.Web.dll、Spring.Web.Mvc4.dll引用
	 2.根据Spring.Mvc4QuickStart下的Web.Config对网站Web.config进行配置
	 3.将Config文件拖到项目里面
	 4.修改Global文件继承类为SpringMvcApplication
	 5.修改Config下面的controllers.xml文件:例如
	 命名空间-Controllers-控制器名
	 <object type="MVC展示数据.Controllers.LoginController, MVC展示数据" singleton="false" >
     <property name="UserInfoBLL" ref="UserInfoBLL" />
     </object>  
	 开始配置BLL层下的UserInfoBLL类的对象
     <object name="UserInfoBLL" type="BLL.UserInfoBLL,BLL" singleton="false" ></object>
	 作用:不用new BLL层对象了，直接根据这个配置文件即可实现创建
	 -------命名空间.Controllers.控制器名
    <object type="MVC展示数据.Controllers.UserInfoController, MVC展示数据" singleton="false" >
	----------获取BLL层StudentBLL的对象
     <property name="StudentBLL" ref="EFHandlerBLL" />
    </object>
    --------命名空间，类名
     <object name="StudentBLL" type="BLL.StudentBLL,BLL" singleton="false" >
     6.这样在上面配置的控制器里面（UserInfoController）就可以这样写:
	  public IStudentBLL  StudentBLL{get;set;} 这时就相当于new了 ，然后就可以直接使用了
	   
	   
  
   【实现限定不登录不能跳转其他界面】
    1.使用过滤器实现---打标记
	 public class LoginCheckAttribute:ActionFilterAttribute
    {
        public override void OnActionExecuting(ActionExecutingContext filterContext) {
            
            if (filterContext.HttpContext.Session["LoginUser"]==null)
            {
                filterContext.HttpContext.Response.Redirect("/Login/Index");
            }
        }
    }
	2.使用控制器实现---继承
	   protected override void OnActionExecuting(ActionExecutingContext filterContext)  {           
            
            if (filterContext.HttpContext.Session["LoginUser"]==null)
            {
                filterContext.HttpContext.Response.Redirect("/Login/Index");
            }    
        }
  【泛型委托】
   1.Predicate:，它必须有一个返回值，而且必须是布尔类型的，同时，它必须有一个输入参数
   2.Func:可以有任意参数(0-16个之间),要有返回值，注意最后一个参数是返回值类型
   3.Action:输入参数的类型是不确定的，但不能有返回值
	var d4 = new Action<int, string>(twoParamNoReturnAction);
	　　static void twoParamNoReturnAction(int a, string b)
　　　　{
	　　　　//do what you want
　　　　}
	----泛型委托在Controller中的使用:
	  var loginUser = UserInfoBLL.LoadExpression(u => u.UName == username & u.Pwd == password).FirstOrDefault();
  【使用泛型查询时赋值语句】:
  UserInfoBLL.LoadExpression(u=>u.UName==username&u.Pwd==password).FirstOrDefault();
  【NoSql】:全称not only sql,及是非关系型数据库
  【Redis】:
   [Memcached和Redis区别]:1.Memcache是多线程的，Redis是单线程的 2.Redis有记录日志，断电后可以恢复数据
   3.Redis通过服务器端配置实现集群,Memcached通过客户端驱动实现集群的
   4.memcached没有数据类型,redis有数据类型
   5.联系:数据都是缓存到内存中
  【Memchched】它就是Socket服务器端,键值对存储。 内存：每个分区中分成多个块，最大块是1M，块的长度是固定的。
  采用惰性删除，及没有一个循环检查机制，减少了CPU的损耗。 
   使用时：闲置>过期>最少访问
  【缓存】HttpRuntime.Cache是应用程序级别的 HttpContext.Current.Cache是针对web上下文定义的
  【权限设计】:设计一张用户表，一张角色表，一张权限表 ----它们都是多对多的关系
   
   cshtml页面中将字符串以html的形式输出:@Html.Raw()
   linq查询语句:.Select(u=>u.Id).ToList();//查询所有id的list集合
  【Session登录问题】:IIS重启会导致所有的Sessoin丢失，解决办法:进程外Session。但由于Session性能问题，舍弃
   Session，用Memcached模拟Session。
   1.以Guid为key，以登录用户为value放到mm里面去。
   Guid guid=Guid.NewGuid();
   -----注;CacheHelper是自己定义的类
   CacheHelper.Set(guid.ToString(),userName,DateTime.Now.AddMinutes(20))//一般以20分钟过期
   2.以mysessionId为key，guid为value写到Cookie里面去
   Response.Cookies["mysessionId"].Value=guid.ToString();
   3.校验类:根据Cookie去查询mm里面有没有对应的值
      string guid = Request["mysessionId"];
                if (!String.IsNullOrEmpty(guid))
                {
                    var rec = Common.CacheHelper.Get(guid);
                    if (rec != null)
                    {
                        return;
                    }
                }
                filterContext.HttpContext.Response.Redirect("/Login/Index");
 -----------------------------
    【mongoDB】:介于关系型数据库和非关系型数据库之间
    无模式:就是属性的个数任意
	文档型数据库:就是以一个文档为单位
    前段注释有这么两种:1.<!----> 2.@**@ 第一种会提交服务器，第二种不会，所以用的时候尽量用第二种
	$("#tt").datagrid("clearSelections");//清除所有选中行
	【工作流】:新建项目选择Workflow->活动
     要想让WInfrom窗体也使用工作流，必须创书签:->Workflow->代码活动
	 
	 
   
  
  
  
  
  
  
  
  
  
  



